import { ICaseConvertor } from "../Interfaces/ICaseConvertor";
import { IClassDescription } from "../Interfaces/IClassDescription";
import { IClassDescriptionV1 } from "../Interfaces/IClassDescriptionV1";
import { ActionFailure } from "../Utils/ActionResult";
import { Logger } from "../Utils/Logger";
import TypescriptDataClassGeneratorV1 from "./TypescriptDataClassGeneratorV1";

var myLogger = console.log;
@Logger.log
export default class TypescriptDataClassGenerator extends TypescriptDataClassGeneratorV1 {
    protected _classSpecification!: IClassDescription;

    public set classDescription(newClassDescription: IClassDescription) {
        this._classSpecification = newClassDescription;
    }

    // Holds a map of functions that generate different type
    // of constructors
    protected _constructorCodeGenerators = new Map<string, () => string>
        (
            [
                ["parameterized", this.generateParameterizedConstructor.bind(this)],
                ["default", this.generateDefaultConstructor.bind(this)]
            ]
        );

    // Holds code for all the fields
    protected _fieldList: string[] = [];

    // Holds getter setter code for the fields
    protected _getterSetterCode: string[] = [];

    // Generates the data class
    @Logger.call()
    public generate(): any {
        // Holds the auto generated comment for the class
        let autoGeneratedComment = `/**${this.N1}* Auto Generated Abstract Data Class${this.N1}*${this.N1}* Generated on : ${new Date().toString()}${this.N1}*/${this.N1}`;

        // Extract the className
        let className = this._classSpecification.className;
        Logger.info(`Generating code for class : `, [className]);

        // Add the decorators of the code (if any)
        let decorators: string[] = this._classSpecification.decorators ?? [];

        // Holds the class code
        let classCode = "";

        // Add the decorators to the class
        if (decorators.length) {
            Logger.info("Decorators found for class", [className]);

            classCode = decorators.reduce((previousValue, decorator) => previousValue + `${decorator}${this.N1}`,
                "");
        } else
            Logger.warn(`Decorators not found for class : ${className}`);


        // Start adding the code for the class
        classCode += `export abstract class ${className}Abstract {${this.N1}`;

        // Holds the fields of the class
        const fields = this._classSpecification.fields;
        fields ? Logger.info("Fields found for class", [`[${className}]`]) : Logger.error(`Fields not found for class`, [`[${className}]`]);

        // Holds the constructors types that have to be generated for this class
        const constructorTypes = this._classSpecification.constructors;

        if (constructorTypes?.size >= 1) {
            // Get the constructor type from the configuration
            let constructorType = this._classSpecification?.constructors?.keys()?.next().value;

            // TypeScript allows just ONE constructor in the class
            // If there are multiple defined in the config, log appropriate info and warning
            if (constructorTypes?.size == 1) {
                Logger.info(`Generating constructor type ${constructorType} for class`, [className]);
            } else {
                Logger.warn(`Multiple constructors found for class [${className}]`);
                Logger.warn(`Generating the first constructor type for class [${className}] : [${constructorTypes?.keys()?.next().value}]`);
            }

            // If the constructor type is valid, generate code
            if (this._constructorCodeGenerators.has(constructorType)) {

                // Get the generator for this constructor
                const constructorCodeGenerator = this._constructorCodeGenerators.get(constructorType) ?? (() => "");

                // Invoke the constructor
                let constructorCode = constructorCodeGenerator();

                // Add the constructor code to the class code
                classCode += constructorCode;

                // If the constructor type was default, generate the fields
                if (constructorType == "default") {
                    this.generateFields();
                }

            } else {
                // Warn the user about unrecognized constructor type
                Logger.error(`Constructor type not recognized`, [`[${constructorType}]`]);
            }
        }
        else
            Logger.warn(`No constructors to be generated for class [${className}]`);

        // Add getters and setters to the class
        for (const fieldNameKey of fields?.keys()) {
            // Generate the getter and setter for this field
            this._getterSetterCode.push(this.generateGetter(fieldNameKey));
            this._getterSetterCode.push(this.generateSetter(fieldNameKey));
        }

        this._fieldList.forEach(fieldCode => classCode += (fieldCode + `${this._fieldList.length > 1 ? this.N1 : ""}`));
        this._getterSetterCode.forEach(getterSetter => classCode += (getterSetter + `${this._getterSetterCode.length > 1 ? this.N1 : ""}`));

        return classCode + `${this.N1}}`;
    }

    // Generates default constructor
    @Logger.call()
    public generateDefaultConstructor(): string {
        let constructorCode = `${this.N1 + this.T1}public constructor() { }${this.N1}`;

        return constructorCode;
    }

    // Generates positional (parameterized) constructor
    @Logger.call()
    public generateParameterizedConstructor(): string {
        // Holds the fields of this class
        const fields = this._classSpecification.fields;

        if (!fields) Logger.error(`No fields found for class`, [`[${this._classSpecification.className}]`]);

        // Holds the constructor code
        let constructorCode = `${this.N1 + this.T1}public constructor (${this.N1}`;
        let fieldCount = 0;

        // Go over each field
        for (const fieldName of fields?.keys()) {
            fieldCount++;

            // Holds the fieldProperties for this field
            const fieldProperties: Map<string, any> = fields.get(fieldName);

            // Holds the modifier of this field
            const modifier: string = fieldProperties.get("modifier") ?? "public";

            // Holds the data type of this field
            const dataType: string = fieldProperties.get("type");
            if (!dataType?.length) Logger.warn(`No data type found for field [${fieldName}] of class [${this._classSpecification.className}]. Using default type [any]`);

            // Holds the default value of this field
            const defaultValue: string = fieldProperties.get("defaultValue");

            if (defaultValue?.length) Logger.info(`Default value found for field [${fieldName}] of class [${this._classSpecification.className}]`, []);
            else Logger.warn(`No default value found for field [${fieldName}] of class [${this._classSpecification.className}]`);

            // Holds the comment for this field
            const comment: string = fieldProperties.get("comment") ?? "";

            // Holds the decorators of this field
            const decorators: string[] = fieldProperties.get("decorators") ?? [];

            if (decorators?.length) Logger.info(`Decorator(s) found for field [${fieldName}] of class [${this._classSpecification.className}]`, []);
            else Logger.warn(`No decorators found for field [${fieldName}] of class [${this._classSpecification.className}]`);

            // Add the decorators to the field
            let decoratorCode = decorators.reduce((previousValue, decorator) => previousValue + `${this.T2}${decorator}${this.N1}`, "");

            constructorCode += `${comment.length ? this.T2 + comment + this.N1 : ""}${decoratorCode}${this.T2}${modifier} ${modifier == "public" ? "" : "_"}${fieldName}: ${dataType ? dataType : "any"}${defaultValue ? " = " + defaultValue : ""}`;

            if (fieldCount != fields.size)
                constructorCode += `,${this.N1}`;

            constructorCode += `${this.N1}`;
        }

        // Complete the constructor code
        constructorCode += `${this.T1}) { }${this.N1}`;

        return constructorCode;

    }

    // Generates the getter for the field
    public generateGetter(fieldName: string): string {
        let getterCode = "";

        // Get the properties for this field
        let fieldProperties: Map<string, any> = this._classSpecification.fields.get(fieldName);

        // Get the type of the field
        let dataType: string = fieldProperties.get("type") ?? "any";

        // Get the getter property map for this field
        let getterPropertyMap: Map<string, any> = fieldProperties.get("getter");
        myLogger(`Getter for ${fieldName}`, getterPropertyMap);

        // Return if there is no map found
        if (!getterPropertyMap) {
            Logger.warn(`No getter to be generated for field [${fieldName}] of class [${this._classSpecification.className}]`);
            return getterCode;
        }

        // If there is a getter property map, get the decorators
        let decorators: string[] = getterPropertyMap?.get("decorators");
        if (decorators?.length) {
            Logger.info(`Accessor decorator(s) found of field [${fieldName}] of [${this._classSpecification.className}]`, [])

            // Add the decorators to the getterCode
            getterCode = decorators.reduce((previousValue, decorator) => previousValue + `${this.T1}${decorator}${this.N1}`, "");
        } else
            Logger.warn(`No accessor decorator(s) found for field [${fieldName}] of [${this._classSpecification.className}]`);

        getterCode += `${this.T1}public abstract get ${fieldName}(): ${dataType};${this.N1}`;

        return getterCode;
    }

    // Generates the setter code for the field
    public generateSetter(fieldName: string): string {
        let setterCode = "";

        // Get the properties for this field
        let fieldProperties: Map<string, any> = this._classSpecification.fields.get(fieldName);

        // Get the type of this field
        let dataType: string = fieldProperties.get("type") ?? "any";

        // Get the setter property map for this field
        let setterPropertyMap: Map<string, any> = fieldProperties.get("setter");
        myLogger(`Setter for ${fieldName}`, setterPropertyMap);

        // If there is no setter map, return
        if (!setterPropertyMap) {
            Logger.warn(`No setter to be generated for field [${fieldName}] of class [${this._classSpecification.className}]`);
            return setterCode;
        }

        // Get the decorators for this setter
        let decorators: string[] = setterPropertyMap?.get("decorators") ?? [];

        if (decorators?.length) {
            Logger.info(`Mutator decorator(s) found for field [${fieldName}] of class [${this._classSpecification.className}]`, []);
            setterCode = decorators.reduce((previousValue, decorator) => previousValue + `${this.T1}${decorator}${this.N1}`, "");
        } else
            Logger.warn(`No mutator decorator(s) found for field [${fieldName}] of class [${this._classSpecification.className}]`);

        setterCode += `${this.T1}public abstract set ${fieldName}(newValue): ${dataType};${this.N1}`;

        return setterCode;
    }

    // Generates code for all fields
    public generateFields() {
        let fields = this._classSpecification.fields;

        if (!fields) Logger.error(`No fields found for class [${this._classSpecification.className}]`, []);

        for (const fieldName of fields?.keys()) {
            this._fieldList.push(this.generateFieldCode(fieldName));
        }
    }

    // Generates field code 
    public generateFieldCode(fieldName: string): string {
        let fieldCode = "";

        // Properties of this field
        let fieldProperties: Map<string, any> = this._classSpecification.fields.get(fieldName);

        // Data type of this field
        let dataType: string = fieldProperties.get("type") ?? "any";

        // Comment for this field
        let comment: string = fieldProperties.get("comment");

        // Holds the decorators for this field
        let decorators: string[] = fieldProperties.get("decorators") ?? [];

        // Modifier for this field
        let modifier: string = fieldProperties.get("modifier") ?? "public";

        // Default value for this field
        let defaultValue: string = fieldProperties.get("defaultValue");

        // Start adding code to the field
        fieldCode += `${this.N1 + this.T1}${comment ? "// " + comment : ""}${this.N1}`;

        // Add decorators to the code
        fieldCode += decorators.reduce((previousValue, decorator) => previousValue + `${this.T1}${decorator}${this.N1}`, "");

        fieldCode += `${this.T1}${modifier} ${modifier == "public" ? fieldName : "_" + fieldName}: ${dataType}${defaultValue ? " = " + defaultValue : ""}`;

        return fieldCode;
    }
}
myLogger = () => { };
